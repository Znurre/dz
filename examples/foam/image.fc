struct Image : Item
{
	data: Memory::empty(),
    source
};

import Memory::Buffer boo();

function u(Image image)
{
	if (Memory::isEmpty(image.data))
	{
		puts("foo");

		return image with
		{
			data: Memory::malloc(1)
		};
	}

	puts("bar");

	return image;
}

function update(EventState events, any parent, (Image image, Image nextItem))
{
    return u(image);
}

function update(EventState events, any parent, ((Image image, Image nextItem), ...controls))
{
	return u(image) -> update(events, parent, ...controls);
}

function process(ApplicationState state, (Image image, ...controls))
{
    return tail process(state, ...controls);
}

function process(ApplicationState state, Image image)
{
    return state.user;
}

function getSource(IconSource source)
{
	let a = toArray(Memory::malloc(200), 0, ...Range::concat(Range::concat("/usr/share/icons/breeze/actions/16/", source.name), ".svg"));

	// printBuf(a);

	return a;
}

import void assignInt(Memory::Buffer dest, i32 offset, i32 value);
import void printBuf(Memory::Buffer buffer);

function toArray(Memory::Buffer storage, i32 offset, (any c, ...remaining))
{
	// printnum(offset);

	assignInt(storage, offset, c);

	return tail toArray(Memory::realloc(storage, offset + 3), offset + 1, ...remaining);
}

function toArray(Memory::Buffer storage, i32 offset, any c)
{
	assignInt(storage, offset, c);
	assignInt(storage, offset + 1, 0);

	return storage;
}

function draw(i64 renderer, any parent, Image image)
{
	puts(@"bar");

	let q = Svg::render(getSource(image.source));

	let surface = SDL::SDL_CreateRGBSurfaceFrom(q.data, q.width, q.height, 32, q.width * 4, 0x000000FFu32, 0x0000FF00u32, 0x00FF0000u32, 0xFF000000u32);
	let texture = SDL::SDL_CreateTextureFromSurface(renderer, surface);

	SDL::SDL_RenderCopy(renderer, texture, 0i64, boundingRect(image));
	SDL::SDL_FreeSurface(surface);

	return nothing;
}
